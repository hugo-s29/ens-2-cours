\documentclass[./main]{subfiles}

\begin{document}
  \chapter{Complexité en espace.}


  \section{Définitions et premières propriétés.}

  \begin{defn}
    L'\textit{espace utilisé} par une machine de Turing déterministe sur une entrée $x$ est le nombre de cases distinctes utilisés sur les rubans de travail\footnote{Pas le ruban d'entrée, ni le ruban de sortie, ceci permet de parler de machine utilisant un espace logarithmique, bien que la taille de l'entrée soit $n$.} au cours de son calcul sur $x$.

    On dit que $M$ fonctionne en espace $s(n)$ si $M$ s'arrête sur toutes ses entrées et utilise un espace au plus $s(n)$ sur toute entrée de taille $n$.

    On note $\intro*\dspace{s(n)}$ l'ensemble des langages reconnus par une machine de Turing déterministe fonctionnant en espace $\mathrm{O}(s(n))$.
  \end{defn}

  \begin{rmk}
    On supposera que, pour le ruban d'entrée, la tête de lecture ne dépassera jamais la fin de l'entrée.
  \end{rmk}

  \begin{exm}
    \begin{itemize}
      \item Un algorithme naïf pour \pbSat\ utilise un espace en~$\mathrm{O}(n)$. En effet, il suffit d'énumérer toutes les valuations possibles avec un compteur binaire de taille $n$, puis de vérifier si une de ces valuations satisfait la formule.
      \item L'addition de deux entiers de taille $n$ peut s'effectuer en espace $\mathrm{O}(\log n)$. En effet, il suffit de stocker les positions des bits en cours d'addition et la retenue.
    \end{itemize}
  \end{exm}

  \begin{defn}
    On dit que $t : \mathds{N} \to \mathds{N}$ est \textit{constructible en espace} s'il existe une machine de Turing qui, sur l'entrée $\texttt{1}^n$ calcule $\texttt{1}^{t(n)}$ en espace $\mathrm{O}(t(n))$.
  \end{defn}

  \begin{prop}
    On a l'inclusion
    \[
      \ntime{f(n)} \subseteq \dspace{f(n)}
    .\] 
  \end{prop}
  \begin{prv}
    Supposons $f$ constructible en espace $(*)$.

    Soit $L \in \ntime{f(n)}$ et $M$ une machine non-déterministe reconnaissant $L$ en temps au plus $c\: f(n)$.
    On code un chemin de calcul de $M$ par $y \in \llbracket 0, R - 1\rrbracket^{c \: f(n)}$ où $R$ désigne le nombre de choix possibles à chaque étape (il dépend de $M$).

    \begin{algorithmic}[1]
      \State Calculer $f(n)$ en espace $\mathrm{O}(f(n))$ 
      \ForAll{$y$ de taille $c\:f(n)$}
      \State{Simuler $M$ sur $x$ en suivant les choix donnés par $y$}
      \If{la simulation accepte}
      \State \textbf{Accepter}
      \EndIf
      \EndFor
      \State \textbf{Rejeter} 
    \end{algorithmic}
    On a un algorithme en espace $f(n)$ qui teste l'appartenance au langage $L$.

    Sans l'hypothèse $(*)$, on peut obtenir la même inclusion avec une légère modification de l'argument. On fait fonctionner le même algorithme pour des chemins de calcul de longueur $t = 1, 2, \ldots$ jusqu'à ce que la simulation de $M$ sur l'entrée de $x$ s'arrête (ce qui arrive forcément si $x \in L$). On s'arrête pour $t = c \: f(n)$ au plus.
  \end{prv}

  \begin{prop}
    On a l'inclusion
    \[
      \dspace{s(n)} \subseteq \dtime{2^{\mathrm{O}(s(n))}}
    ,\]
    dès lors que $s(n) \ge \log n$.
  \end{prop}

  \begin{prv}
    Soit $N$ tel que, si un calcul prend un temps  plus long que $N$, alors il boucle.
    Nous allons montrer que $N = 2^{\mathrm{O}(s(n))}$.
    On compte le nombre de configurations distinctes possibles d'une machine $M$ sur l'entrée $x$ de taille $n$.
    Une configuration est donnée\footnote{On oublie la position de la tête de lecture sur le ruban de sortie, vu qu'elle n'influe pas le calcul (car écriture uniquement).} par :
    \begin{itemize}
      \item l'état courant (il y a au plus $|Q|$ possibilités) ;
      \item la position de la tête de lecture sur le ruban d'entrée (il y a au plus $n$ possibilités) ;
      \item le contenu des cases utilisées sur les rubans de travail (il y a au plus $|\Gamma|^{s(n)}$ possibilités) ;
      \item la position des têtes de lecture sur les rubans de travail (il y a au plus $s(n)^k$ possibilités où $k$ est le nombre de rubans de travail).
    \end{itemize}
    D'où la borne annoncée.
  \end{prv}

  \begin{rmk}
    A-t-on $\dspace{1} \subseteq \dtime{1}$ ?
    Non ! En effet, retourner le dernier caractère de l'entrée se fait en espace $\mathrm{O}(1)$ mais pas en temps $\mathrm{O}(1)$.
  \end{rmk}

  \begin{defn}
    On définit $\intro*\ls = \dspace{\log n}$.
  \end{defn}
  \begin{crlr}
    On a les inclusions
    \[
    \ls \subseteq \p \subseteq \np \subseteq \pspace
    ,\]
    où $\pspace$ est l'ensemble des problèmes définis en espace polynomial (défini plus tard).
    \qed
  \end{crlr}

  \begin{thm}
    Si deux fonctions $f, g : \{\texttt{0}, \texttt{1}\}^\star \to \{\texttt{0}, \texttt{1}\}^\star$ sont calculables en espace $s(n) \ge \log n$ alors leur composée $g \circ f$ est calculable en espace $\mathrm{O}(s(|x|)) + s(|f(x)|)$.
  \end{thm}

  \begin{prv}
    L'idée est de calculer un bit de $f(x)$ uniquement quand on en a besoin pour calculer $g(f(x))$.

     \begin{lem}
      Étant donné $i$, on peut calculer le $i$-ème bit de $f(x)$ en espace $\mathrm{O}(s(|x|))$.
    \end{lem}
    \begin{prv}
      Faire fonctionner $M_f$ (la machine calculant $f$ en espace logarithmique) sans écrire sur le ruban de sortie, mais simplement en comptant le nombre de bits que l'on voulait écrire.
      Dès lors que $i$ est atteint, on renvoie le bit courant : c'est le $i$-ème bit de $f(x)$.
    \end{prv}

    On utilise ensuite l'algorithme suivant :

    \begin{algorithmic}[1]
      \State $i \gets 0$
      \While{$M_g$ ne s'est pas arrêtée} 
      \State Calculer le $i$-ème bit de $f(x)$ (par le lemme)
      \State L'écrire sur le ruban d'entrée de $M_g$
      \State Effectuer un pas de calcul de $M_g$ 
      \If{la tête \texttt{→} sur le ruban d'entrée de $M_g$}
      \State $i \gets i +1$ 
      \ElsIf{la tête \texttt{←} sur le ruban d'entrée de $M_g$}
      \State $i \gets i -1$ 
      \EndIf
      \EndWhile
    \end{algorithmic}
  \end{prv}

  \begin{crlr}
    Si $f$ et $g$ sont calculables en espace $\mathrm{O}(\log n)$ alors $g \circ f$ est calculable en espace $\mathrm{O}(\log n)$.
    \qed
  \end{crlr}

  \section{Hiérarchie en espace.}

  \begin{thm}
    Si $s$ est constructible en espace et $s(n) \ge \log n$ alors il existe un langage reconnaissable en espace $\mathrm{O}(s(n))$ mais pas en espace $\mathrm{o}(s(n))$.
  \end{thm}

  \begin{prv}
    L'idée est de faire une preuve par diagonalisation.
    On construit une machine $D$ qui fonctionne en espace $\mathrm{O}(s(n))$ et qui reconnaît un langage $A$ différent de tous les langages reconnus en espace $\mathrm{o}(s(n))$.
    Pour cela, $D$ simule une machine tournant en espace au plus $\mathrm{o}(s(n))$ et on a que $D(\code{M})$ accepte ssi $M(\code{M})$ rejette (et inversement).

    \begin{lem}
      Si $L \in \dspace{s(n)}$  alors $L$ est reconnaissable en $\mathrm{O}(s(n))$ par une machine à un ruban de travail dont l'alphabet est $\{\texttt{0},\texttt{1},\blank,\start\}$.
      \qed
    \end{lem}

    \begin{lem}
      Il existe une machine de Turing universelle $U$ qui prend en entrée $\code{M, x}$ avec  $x \in \{\texttt{0},\texttt{1}\}^\star$ et $M$ une machine à un ruban de travail et dont l'alphabet est $\{\texttt{0},\texttt{1},\blank,\start\}$, et qui simule $M$ sur l'entrée $x$ en espace $\mathrm{O}(s(n))$ si $M$ fonctionne en espace $s(n)$.
      On peut même supposer que $U$ ne possède qu'un seul ruban de travail.
      \qed
    \end{lem}

    À l'aide de ces deux lemmes, on donne l'algorithme suivant (machine $D$).

    \begin{algorithmic}[1]
      \State Lire l'entrée $w \in \{\texttt{0},\texttt{1}\}^\star$ (notons $n$ sa taille)
      \State Calculer $s(n)$ en espace $\mathrm{O}(s(n))$
      \State Réserver $s(n)$ cases sur le ruban de travail
      \If{$w$ n'est pas de la forme $\code{M}\texttt{1}\texttt{0}^\star$\footnote{Pour une certaine machine $M$}}
      \State \textbf{Rejeter}
      \EndIf
      \State Simuler $M$ sur l'entrée $w$
      \If{on dépasse $2^{2 \cdot s(n)}$ étapes ou $s(n)$ cases mémoires}
      \State \textbf{Rejeter}
      \EndIf
      \If{$M$ accepte}
      \textbf{Rejeter}
      \Else
      \textbf{ Accepter}
      \EndIf
    \end{algorithmic}

    On a que la machine $D$ s'arrête sur toute entrée et fonctionne en espace $\mathrm{O}(s(n))$.

    De plus, si $B$ est un langage décidable en $\mathrm{o}(s(n))$ par une machine $M$, alors $B$ est différent du langage de $A$.
    En effet, $D$ simule $M$ en espace $\mathrm{o}(s(n))$.
    \begin{itemize}
      \item Ainsi, il existe $n_0$ tel que, pour $n \ge n_0$, $D$ fera une simulation en espace strictement plus petit que $\mathrm{s(n)}$, donc ne manquera pas d'espace.
      \item Aussi, comme $M$ fonctionne en temps $2^{\mathrm{o}(s(n))}$ alors la simulation sera en temps strictement plus petit que $2^{s(n)}$ pour $n \ge n_1$ pour un certain $n_1$, donc ne manquera pas de temps.
    \end{itemize}
    En posant $n_2 := \max(n_0, n_1)$, on a que sur l'entrée $\code{M}\texttt{1}\texttt{0}^{n_2}$, la simulation de $M$ se fera jusqu'au bout et $D$ donne une réponse différente de $M$ sur la même entrée.
    D'où les deux langages $B$ et $A$ sont différents.

  \end{prv}





  \begin{crlr}
    On a les inclusions strictes suivantes :\[
      \ls \subsetneq \dspace{n} \subsetneq \dspace{n^2} \subsetneq \cdots \subsetneq \pspace
    .\] 
  \end{crlr}




  \section{Complexité en espace non-déterministe.}

  \begin{defn}
    Une machine non-déterministe $M$ fonctionne en espace au plus $s(n)$ si, sur toute entrée de taille $n$, chaque chemin de calcul utilise un espace au plus $s(n)$ (sur les rubans de travail).

    On note $\intro*\nspace{s(n)}$ l'ensemble des langages reconnus par une machine de Turing non-déterministe en espace  $\mathrm{O}(s(n))$.
  \end{defn}

  \begin{defn}
    On définit $\intro*\nls := \nspace{\log n}$.
  \end{defn}

  On a prouvé précédemment que $\dspace{s(n)} \subseteq \dtime{2^{s(n)}}$ (lorsque l'on a que $s(n) \ge \log n$).
  On peut améliorer cette inclusion avec $\nspace{s(n)}$, comme $\dspace{s(n)} \subseteq \nspace{s(n)}$.

  \begin{prop}
    On a \[
    \nspace{s(n)} \subseteq \dtime{2^{\mathrm{O}(s(n))}}
    ,\]  pour $s(n) \ge \log n$.
  \end{prop}
  \begin{prv}
    On considère $G_x$ le \textit{\textbf{graphe}} (orienté) \textit{\textbf{des configurations}}  de $M$ sur l'entrée $x$ de taille $n$, où $c_1 c_2 \in \mathrm{E}(G_x)$ ssi $M$ peut passer de la configuration $c_1$ à la configuration $c_2$ en un seul pas de calcul.

    \begin{lem}
      Le graphe $G_x$ a $2^{\mathrm{O}(s(n))}$ sommets, et on peut le construire en espace $\mathrm{O}(s(n))$. \qed
    \end{lem}

    On explore $G_x$ à partir de la configuration initiale $c_\text{initiale}$ et on accepte si on atteint une configuration d'acceptation.
  \end{prv}

  \begin{rmk}
    On n'a pas utilisé l'hypothèse que $M$ s'arrête sur toutes ses entrées.
  \end{rmk}

  \section{Formules booléennes quantifiés, $\pspace$.}

  \begin{defn}
    On définit
    \[
      \intro*\pspace := \bigcup_{k \ge 1} \dspace{n^k}
    .\]
  \end{defn}

  \begin{thm}[Savitch]
    On a $\nspace{s(n)} \subseteq \dspace{s(n)^2}$ si $s(n) \ge \log n$.\footnote{Depuis sa preuve, on n'a jamais réussi à améliorer ce résultat, ni montrer qu'un facteur carré est nécessaire.}
  \end{thm}

  \begin{rmk}
    On peut aussi définir la classe $\mathsf{NPSPACE}$ mais cette classe est égale à $\pspace$ par Savitch.
    On a donc
    \[
      \ls \subseteq \nls \subseteq \p \subseteq \np \underset {(*)} \subseteq \pspace \underset {(**)} \subseteq \overbrace{\intro*\exptime}^{\bigcup_{k \ge 1} \dtime{2^{n^k}}}
    ,\] 
    où 
    \begin{itemize}
      \item $(*)$ est vraie car $\ntime{t(n)} \subseteq \dspace{t(n)}$ ;
      \item $(**)$ est vraie car $\dspace{s(n)} \subseteq \dtime{2^{\mathrm{O}(s(n))}}$.
    \end{itemize}
    On sait, de plus, que $\p \subsetneq \exptime$ par la hiérarchie en temps (variante (vue en TD) de la hiérarchie en espace vue avant).
    Et, que $\ls \subsetneq \pspace$ par le théorème de Savitch et la hiérarchie en espace.
  \end{rmk}

  On autorise des quantificateurs universels et existentiels aux formules vues précédemment.

  \begin{exm}
    Les formules
    \begin{itemize}
      \item $\forall x \: \exists y \: \big(\overbrace{(x \vee y) \wedge (\bar{x} \vee \bar{y})}^{\text{c'est $x \operatorname{xor} y$}}\big)$
      \item $\exists y \: \forall x \:  \big((x \vee y) \wedge (\bar{x} \vee \bar{y})\big)$
    \end{itemize}
    sont des formules booléennes quantifiées.
    La première est vraie (avec $y = \bar{x}$) mais pas la seconde (avec $x = y$).
    On suppose que les quantificateurs sont tous en début de formule (forme prénexe).
  \end{exm}

  \begin{defn}
    On définit le problème \pbQBF\ comme 
    \showQBF
  \end{defn}

  \begin{prop}
    On a $\pbQBF \in \pspace$.
  \end{prop}
  \begin{prv}
    On utilise l'algorithme suivant.
    \begin{enumerate}
      \item Si $F$ ne contient pas de quantificateurs, accepter si $F$ s'évalue à vrai et rejeter si $F$ s'évalue à faux.
      \item Si $F = \exists x \: G$, on décide récursivement avec  $G[x := 0]$ et  $G[x := 1]$.
        Si une de ces formules s'évalue à vrai, accepter sinon rejeter.
      \item Si $F = \forall x \: G$, on décide récursivement avec  $G[x := 0]$ et  $G[x := 1]$.
        Si une de ces formules s'évalue à faux, rejeter sinon accepter.
    \end{enumerate}
    Cet algorithme utilise un espace linéaire.
  \end{prv}

  \begin{thm}
    Le problème \pbQBF\ est $\pspace$-complet.
  \end{thm}
  \begin{prv}
    Supposons que $A$ est résolu en espace $n^k$ par une machine~$M$ à un ruban.
    On va montrer que $A \redP \pbQBF$.

    \begin{figure}[H]
      \centering
      \begin{tikzpicture}
        \directlua{draw_spacetime_diagram({
          tape_width = 7,
          steps = {
            {content = {'1', '0', '1'}, head_pos = 1},
            {content = {'1', '1', '1'}, head_pos = 2},
            {content = {'1', '1', '0'}, head_pos = 3},
            {content = {'1', '1', '0', '0'}, head_pos = 4},
            {content = {'1', '1', '1', '0'}, head_pos = 3}
          }
        })}
      \end{tikzpicture}
      \caption{Exemple de diagramme espace-temps}
      \label{fig:space-time-diagram2}
    \end{figure}
    
    On considère le diagramme espace-temps de taille $n^k$ en espace et $2^{c \cdot n^k}$ en temps.
    On ne peut pas simplement utiliser la même preuve que pour \pbSat\ car le diagramme est exponentiel.

    On construit une formule $\phi_t(c_1, c_2)$ qui exprime qu'on peut aller de la configuration $c_1$ en la configuration $c_2$ en au plus $2^t$ étapes de calcul.

    On a donc que $M$ accepte si $\phi_{c \cdot n^k}(c_\text{initiale}, c_\text{finale})$.\footnote{On peut considérer qu'il y a une unique configuration acceptante, quitte à transformer tout état acceptant en un état qui efface tout le ruban et remet la tête en position initiale.}

    La formule $\phi_{0}(c_1, c_2)$ est de taille polynomiale (\textit{c.f.}\ preuve du théorème de Cook).

    Pour aller de $\phi_t$ à $\phi_{t+1}$, on cherche la configuration du milieu.
    On pourrait utiliser $(*) := \exists c\: \phi_t(c_1, c) \wedge \phi_t(c, c_2)$ qui est correcte mais trop couteuse (taille exponentielle).
    On choisit plutôt :
    \[
      \exists c \: \forall c_3 \: \forall c_4 \: \big[ (c_3 = c_1 \wedge c_4 = c) \vee (c_3 = c \wedge c_4 = c_2)  \big] \Rightarrow \phi_t(c_3, c_4)
    .\]
    Cette formule est logiquement équivalente à $(*)$ (en regardant les cas où $(c_3, c_4) = (c_1, c)$ et $(c_3, c_4) = (c, c_2)$).
    Il est important de se rappeler que que $c$, $c_3$, $c_4$ ne sont pas des variables mais des $n$-uplets  de taille $\mathrm{O}(n^k)$ variables booléennes.
    La taille de $\phi_{t+1}$ augmente de $\mathrm{O}(n^k)$ par rapport à la taille de $\phi_t$.
    Au final, on est de taille $\mathrm{O}(n^{2k})$.\footnote{Le passage quadratique est similaire au théorème de Savitch.}
  \end{prv}

  Le problème \pbQBF\ est "le" problème $\pspace$-complet. En TD, on fera des réductions de certains problèmes à \pbQBF.


  \section{Problème {\textrm{\textmd{\pbPath}}}\ et théorème de Savitch.}

  \begin{crlr}
    On a $\nls \subseteq \dspace{\log^2 n}$.
  \end{crlr}

  \begin{prop}
    On a que $\pbPath \in \dspace{\log^2 n}$, où

    \showPath
  \end{prop}

  \begin{rmk}
    En TD, on a vu que \pbPath\ est $\nls$-complet, et donc la proposition implique le corollaire.
    En effet, soit $A \in \nls$ et $x \in \{\texttt{0},\texttt{1}\}^n$, on a 
    \[
    x \in A \iff f(x) \in \pbPath
    ,\]
    où $f : A \redL \pbPath$ est la réduction en espace logarithmique (car le problème \pbPath\ est $\nls$-complet).
    La construction de $f(x)$ se fait en espace $\mathrm{O}(\log n)$ et décider si $f(x) \in \pbPath$ ou non peut se faire en espace $\mathrm{O}(\log^2 |f(x)|)$, or $|f(x)|$ est polynomial en $|x| = n$, d'où la borne annoncée.
  \end{rmk}

  \vspace{12pt}

  \begin{prv}[de la proposition]
    On donne un algorithme $\textsf{path}(G, u, v, i)$ en espace $\mathrm{O}(\log^2 n)$ qui décide s'il existe, dans $G$, un chemin de $u$ à $v$ de longueur au plus $2^i$.
    On pourra donc résoudre \pbPath\ en appelant $\textsf{path}(G, s, t, \left\lceil \log n \right\rceil)$.

    \begin{algorithmic}[1]
      \Procedure{$\mathsf{path}$}{$G, u, v, i$}
      \If{$i = 0$}
      \If{$u v \in \mathrm{E}(G)$ ou $u = v$} \textbf{Accepter}
      \Else \textbf{ Rejeter}
      \EndIf
      \EndIf
      \ForAll{sommet $w \in \mathrm{V}(G)$}
      \If{$\mathsf{path}(G, u, w, i - 1)$ et $\mathsf{path}(G, w, v, i-1)$}
      \State \textbf{Accepter}
      \EndIf
      \EndFor
      \State \textbf{Rejeter}
      \EndProcedure
    \end{algorithmic}

    Pour la correction, on montre si $\mathsf{path}(G, u, v, i)$ accepte alors il existe un chemin de longueur au plus $2^i$ par récurrence sur $i$.
    \begin{itemize}
      \item Pour le cas $i = 0$, c'est bon par le premier "\textbf{si}".
      \item Pour l'hérédité, si on a un chemin de longueur au plus $2^{i-1}$ de $u$ à $w$ et un chemin de longueur au plus $2^{i-1}$ de $w$ à $v$, on concatène ces chemins pour obtenir un chemin de $u$ à $v$ de longueur au plus $2^i$.
    \end{itemize}

    Réciproquement, s'il existe un chemin de $u$ à $v$ de longueur au plus $2^i$, alors $\mathsf{path}(G, u, v, i)$ accepte, car il suffit de choisir $w$ comme sommet milieu du chemin.

    On a $\mathrm{O}(\log n)$ appels récursifs; et à chaque appel, on doit mémoriser $w$ ce qui demande $\mathrm{O}(\log n)$ bits.
    On en déduit une complexité en espace en $\mathrm{O}(\log^2 n)$.
  \end{prv}

  \vspace{12pt}

  \begin{prv}[du théorème de Savitch]
    Supposons que $A$ peut être résolu par une machine non-déterministe $M$ en espace $\mathrm{O}(s(n))$ où $s(n)$ est constructible en espace.
    Soit $x \in \{\texttt{0},\texttt{1}\}^n$  une instance de~$A$.

    On considère le graphe $G_x$ des \textit{\textbf{configurations potentielles}} de la machine $M$ sur l'entrée $x$, c'est-à-dire l'ensemble des configurations avec $x$ en entrée et au plus $c \cdot s(n)$ cases utilisées sur chaque ruban de travail.

    \begin{lem}
      Le graphe $G_x$ a $2^{\mathrm{O}(s(n))}$ sommets et peut être construit en espace $\mathrm{O}(s(n))$.
      \qed
    \end{lem}

    On a que 
    \[
    x \in A \quad\quad \iff \quad \quad (G_x, s, t) \in \pbPath
    ,\] 
    où $s$ est la configuration initiale de $M$ sur l'entrée $x$ et $t$ la configuration acceptante (qu'on supposera unique, \textit{c.f.}\ preuve de la $\pspace$-complétude de \pbQBF).
    Par le lemme, on a que $(G_x, s, t)$ se fait en espace $\mathrm{O}(s(n))$. Décider si $(G_x, s, t) \in \pbPath$ se fait en espace $\mathrm{O}(\log^2 |G_x|)$ donc $\mathrm{O}(s(n)^2)$.
  \end{prv}

  \begin{rmk}
    La preuve précédente utilise deux résultats
    \begin{itemize}
      \item le théorème de composition \textit{amélioré} :
    \end{itemize}
    \begin{thm}[Composition]
      Soient $f$ et $g$ deux fonctions calculables en espace $s_f(n)$ (\textit{resp}.\ $s_g(n)$).
      On peut calculer la composée  $(f \circ g)(x)$ en espace $\mathrm{O}(s_g(|x|)) + s_f(|g(x)|)$.
      \qed
    \end{thm}
    \begin{itemize}
      \item et le fait que l'on pourra supprimer l'hypothèse de constructibilité de $s(n)$ :

        Pour cela, on essaye $s(n) = 1, 2, \ldots$ et on s'arrête à $s(n) = i$ si aucune configuration de taille  $i + 1$ n'est accessible à partir de la configuration initiale sur l'entrée $x$ (appel à l'algorithme pour \pbPath).
    \end{itemize}
  \end{rmk}

  \begin{rmk}
    Le problème \pbPath\ dans les graphes non-orientés est dans $\ls$ ! C'est un résultat récent (2005).
  \end{rmk}

  La prochaine fois, on s'intéresse aux oracles.
\end{document}
